/**
*
*   Pattern.js
*   @version: 0.1
*
*   Pattern Matching Algorithms implemented in JavaScript
*   https://github.com/foo123/PatternMatchingAlgorithms
*
**/!function ( root, name, deps, factory, undef ) {

    "use strict";
    //
    // export the module in a umd-style generic way
    deps = ( deps ) ? [].concat(deps) : [];
    var A = Array, AP = A.prototype, i, dl = deps.length, mods = new A( dl ), mod;
        
    // node, commonjs, etc..
    if ( "object" === typeof( module ) && module.exports ) 
    {
        if ( undef === module.exports[name] )
        {
            for (i=0; i<dl; i++)  mods[i] = module.exports[ deps[i][0] ] || require( deps[i][1] )[ deps[i][0] ];
            mod = factory.apply(root, mods );
            // allow factory just to add to existing modules without returning a new module
            module.exports[ name ] = mod || 1;
        }
    }
    
    // amd, etc..
    else if ( "function" === typeof( define ) && define.amd ) 
    {
        define( ['exports'].concat( deps.map(function(d){return d[1];}) ), function( exports ) {
            if ( undef === exports[name] )
            {
                var i, args = AP.slice.call( arguments, 1 ), dl = args.length;
                for (i=0; i<dl; i++)   mods[i] = exports[ deps[i][0] ] || args[ i ];
                mod = factory.apply(root, mods );
                // allow factory just to add to existing modules without returning a new module
                exports[ name ] = mod || 1;
            }
        });
    }
    
    // browsers, other loaders, etc..
    else
    {
        if ( undef === root[name] )
        {
            
            for (i=0; i<dl; i++)  mods[i] = root[ deps[i][0] ];
            mod = factory.apply(root, mods );
            // allow factory just to add to existing modules without returning a new module
            root[name] = mod || 1;
        }
    }


}(  /* current root */          this.self || this, 
    /* module name */           "Pattern",
    /* module dependencies */   null, 
    /* module factory */        function( undef ) {

        /* custom exports object */
        var EXPORTS = {};
        
        /* main code starts here */

/**
*
*   Pattern.js
*   @version: 0.1
*
*   Pattern Matching Algorithms implemented in JavaScript
*   https://github.com/foo123/PatternMatchingAlgorithms
*
**/

    "use strict";
    
    // http://en.wikipedia.org/wiki/String_searching_algorithm
    var Pattern = EXPORTS.Pattern = { VERSION: "0.1" };
    
    /*
        space,
        digits,
        capital latin letters,
        lower latin letters
    */
    Pattern.ALPHABET = " 0123456789ABCDEFQHIJKLMNOPQRSTUVWXYZabcdefqhijklmnopqrstuvwxyz";
    
    Pattern.utils = { 
        array_fill: function(len, val) {
            var a = new Array(len), i;
            if ( 'function' === typeof(val) )
            {
                for (i=0; i<len; i++)
                {
                    a[ i ] = val( i );
                }
            }
            else
            {
                for (i=0; i<len; i++)
                {
                    a[ i ] = val;
                }
            }
            return a;
        },
        
        alphabet_index: function( c ) {
            // Returns the index of the given character in the English alphabet, counting from 0.
            //return ALPHABET.indexOf( c ); c.toLowerCase( ).charCodeAt( 0 ) - 97; // 'a' is ASCII character 97
            var ch = c.charCodeAt( 0 );
            // space
            if ( 32 >= ch ) return 0;
            // digit
            if ( 48 <= ch && 57 >= ch ) return ch - 47; // -48+1
            // capital latin letter
            if ( 65 <= ch && 90 >= ch ) return ch - 54; // -65+11
            // lower latin letter
            return ch - 60; // -97+11+26
        },
        
        alphabet_map: function( ) {
            return { 
                 " ": 0
                ,"0": 0
                ,"1": 0
                ,"2": 0
                ,"3": 0
                ,"4": 0
                ,"5": 0
                ,"6": 0
                ,"7": 0
                ,"8": 0
                ,"9": 0
                ,"A": 0
                ,"B": 0
                ,"C": 0
                ,"D": 0
                ,"E": 0
                ,"F": 0
                ,"Q": 0
                ,"H": 0
                ,"I": 0
                ,"J": 0
                ,"K": 0
                ,"L": 0
                ,"M": 0
                ,"N": 0
                ,"O": 0
                ,"P": 0
                ,"Q": 0
                ,"R": 0
                ,"S": 0
                ,"T": 0
                ,"U": 0
                ,"V": 0
                ,"W": 0
                ,"X": 0
                ,"Y": 0
                ,"Z": 0
                ,"a": 0
                ,"b": 0
                ,"c": 0
                ,"d": 0
                ,"e": 0
                ,"f": 0
                ,"q": 0
                ,"h": 0
                ,"i": 0
                ,"j": 0
                ,"k": 0
                ,"l": 0
                ,"m": 0
                ,"n": 0
                ,"o": 0
                ,"p": 0
                ,"q": 0
                ,"r": 0
                ,"s": 0
                ,"t": 0
                ,"u": 0
                ,"v": 0
                ,"w": 0
                ,"x": 0
                ,"y": 0
                ,"z": 0
            };
        },
        
        reverse: function( s ) {
            return s.split( '' ).reverse( ).join( '' );
        }
    };
    
    Pattern.Matcher = function( pattern ) {
        this.pattern( pattern || null );
    };
    Pattern.Matcher.prototype = {
        constructor: Pattern.Matcher,
        
        reference: null,
        description: '',
        
        _pattern: null,
        
        dispose: function( ) {
            this._pattern = null;
            return this;
        },
        
        pattern: function( pattern ) {
            this._pattern = pattern || null;
            return this;
        },
        
        match: function( s, offset ) {
            return -1;
        }
    };
    
    !function(Pattern, undef){

    "use strict";
    
    //
    //  Builtin Matcher
    //  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf
    //
    
    Pattern.BuiltinMatcher = function( pattern ) {
        Pattern.Matcher.call(this, pattern);
    };
    Pattern.BuiltinMatcher.prototype = Object.create( Pattern.Matcher.prototype );
    Pattern.BuiltinMatcher.prototype.reference = 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf';
    Pattern.BuiltinMatcher.prototype.description = "This is JavaScript's builtin string search algorithm (<i>String.prototype.indexOf</i>), usually a variation of Knuth-Morris-Pratt or Boyer-Moore algorithms.";
    Pattern.BuiltinMatcher.prototype.match = function( s, offset ) {
        var p = this._pattern, m = p.length, n = s.length;
        
        if ( arguments.length < 2 ) offset = 0;
        if ( offset < 0 ) offset += n;
        if ( n > 0 && m > 0 && n >= offset+m )
        {
            return s.indexOf( p, offset );
        }
        return -1;
    };
    
}(Pattern);!function(Pattern, undef){

    "use strict";
    
    //
    //  "Naive" String Matcher
    //  http://en.wikipedia.org/wiki/String_searching_algorithm
    //
    
    Pattern.NaiveMatcher = function( pattern ) {
        Pattern.Matcher.call(this, pattern);
    };
    Pattern.NaiveMatcher.prototype = Object.create( Pattern.Matcher.prototype );
    Pattern.NaiveMatcher.prototype.reference = 'http://en.wikipedia.org/wiki/String_searching_algorithm';
    Pattern.NaiveMatcher.prototype.description = "This is a &quot;<i>naive</i>&quot; string search algorithm, in that it tests each succesive position of the input text to see if the pattern matches and does not use information about the pattern (or the text) in order to speed up the search.";
    Pattern.NaiveMatcher.prototype.match = function( s, offset ) {
        var p = this._pattern, n = s.length, m = p.length, i;
        
        if ( arguments.length < 2 ) offset = 0;
        if ( offset < 0 ) offset += n;
        if ( n > 0 && m > 0 && n >= offset+m )
        {
            n = n-m+1;
            for (i=offset; i<n; i++)
            {
                if ( s.slice(i, i+m) === p ) return i;
            }
        }
        return -1;
    };
    
}(Pattern);!function(Pattern, undef){

    "use strict";
    
    //
    //  Rabin-Karp Matcher
    //  http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=BA184C94C16CB23D5FA7329E257E3713?doi=10.1.1.86.9502&rep=rep1&type=pdf
    //  http://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm
    //
    
    var pow = Math.pow,
        alphabet_index = Pattern.utils.alphabet_index,
        D = Pattern.ALPHABET.length, // typically the length of the alphabet |S|, here only ASCII alphabet assumed
        Q = 3989 // prime number so that 10*Q can fit in one WORD (i.e 2^16 bits)
    ;
    
    Pattern.RabinKarpMatcher = function( pattern ) {
        Pattern.Matcher.call(this, pattern);
    };
    Pattern.RabinKarpMatcher.prototype = Object.create( Pattern.Matcher.prototype );
    Pattern.RabinKarpMatcher.prototype.reference = 'http://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm';
    Pattern.RabinKarpMatcher.prototype.description = "The Rabin–Karp algorithm is a string searching algorithm  that uses &quot;<i>hashing</i>&quot; to find any one of a set of pattern strings in a text. For text of length n and p patterns of combined length m, its average and best case running time is O(n+m) in space O(p), but its worst-case time is O(nm).";
    Pattern.RabinKarpMatcher.prototype.match = function( s, offset ) {
        var p = this._pattern, n = s.length, m = p.length, 
            h, pq, sq, i
        ;
        
        if ( arguments.length < 2 ) offset = 0;
        if ( offset < 0 ) offset += n;
        if ( n > 0 && m > 0 && n >= offset+m )
        {
            h = pow(D, m-1) % Q;
            pq = 0; sq = 0;
            
            // pre-processing
            for (i=0; i<m; i++)
            {
                pq = ( pq*D + alphabet_index(p.charAt( i )) ) % Q;
                sq = ( sq*D + alphabet_index(s.charAt( offset+i )) ) % Q;
            }
            
            // matching
            n = n-m;
            for (i=offset; i<=n; i++)
            {
                // pq, sq, D-base arithmetic code, used as a quick "hash" test
                // worst case: many hash collisions -> "naive" matching
                if ( pq === sq ) 
                {
                    if ( s.slice(i, i+m) === p ) return i;
                }
                // update text hash for next char using Horner algorithm
                if ( i < n ) 
                {
                    sq = ( D*(sq - h*alphabet_index(s.charAt(i))) + alphabet_index(s.charAt(i+m)) ) % Q;
                    if ( sq < 0 ) sq += Q;
                }
            }
        }
        return -1;
    };
    
}(Pattern);!function(Pattern, undef){

    "use strict";
    
    //
    //  Finite State Automaton (FSA) Matcher
    //  http://en.wikipedia.org/wiki/Finite-state_machine
    //  http://en.wikipedia.org/wiki/String_searching_algorithm
    //
    
    var min = Math.min, array_fill = Pattern.utils.array_fill,
        alphabet_map = Pattern.utils.alphabet_map,
        ALPHABET = Pattern.ALPHABET,
        ALPHABET_LEN = ALPHABET.length
    ;
    
    function isSuffix( s1, s2 )
    {
        return s1 === s2.slice( -s1.length );
    }
    
    function computeTransitionMatrix( p )
    {
        var m = p.length, q, a, aa, k, delta;
        
        delta = array_fill( m, alphabet_map );
        
        for (q=0; q<m; q++)
        {
            for (a=0; a<ALPHABET_LEN; a++)
            {
                k = min(m, q+1);
                aa = ALPHABET.charAt( a );
                while ( k > 0 && !isSuffix(p.slice(0, k), p.slice(0, q)+aa) ) k--;
                delta[ q ][ aa ] = k;
            }
        }
        return delta;
    }
    
    Pattern.FSAMatcher = function( pattern ) {
        Pattern.Matcher.call(this, pattern);
    };
    Pattern.FSAMatcher.prototype = Object.create( Pattern.Matcher.prototype );
    Pattern.FSAMatcher.prototype.reference = 'http://en.wikipedia.org/wiki/Finite-state_machine';
    Pattern.FSAMatcher.prototype.description = "The Finite State Automaton matcher (or FSA matcher) searches a text for a pattern, by creating a deterministic finite automaton (DFA) which is then used to parse the text. The FSA method is also used for matching a regular expression pattern."
    Pattern.FSAMatcher.prototype._delta = null;
    Pattern.FSAMatcher.prototype.dispose = function( ) {
        this._pattern = null;
        this._delta = null;
        return this;
    };
    Pattern.FSAMatcher.prototype.pattern = function( pattern ) {
        this._pattern = pattern || null;
        if ( this._pattern )
        {
            this._delta = computeTransitionMatrix( this._pattern );
        }
        else
        {
            this._delta = null;
        }
        return this;
    };
    Pattern.FSAMatcher.prototype.match = function( s, offset ) {
        var p = this._pattern, delta = this._delta, 
            n = s.length, m = p.length, q, i;
        
        if ( arguments.length < 2 ) offset = 0;
        if ( offset < 0 ) offset += n;
        if ( n > 0 && m > 0 && n >= offset+m )
        {
            q = 0;
            for (i=offset; i<n; i++)
            {
                q = delta[ q ][ s.charAt( i ) ];
                if ( m === q ) return i-m+1;
            }
        }
        return -1;
    };
    
}(Pattern);!function(Pattern, undef){

    "use strict";
    
    //
    //  Knuth-Morris-Pratt Matcher
    //  http://www.eecs.ucf.edu/~shzhang/Combio09/kmp.pdf
    //  http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm
    //
    
    var array_fill = Pattern.utils.array_fill;
    
    function computePrefix( p )
    {
        var m = p.length, k, q,
            prefix = array_fill( m, 0 )
        ;
        
        k = 0;
        for (q=1; q<m; q++)
        {
            while ( k > 0 && p.charAt( k+1 ) !== p.charAt( q ) ) k = prefix[ k ];
            
            if ( p.charAt( k+1 ) === p.charAt( q ) ) k++;
            
            prefix[ q ] = k;
        }
        return prefix;
    }
    
    Pattern.KnuthMorrisPrattMatcher = function( pattern ) {
        Pattern.Matcher.call(this, pattern);
    };
    Pattern.KnuthMorrisPrattMatcher.prototype = Object.create( Pattern.Matcher.prototype );
    Pattern.KnuthMorrisPrattMatcher.prototype.reference = 'http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm';
    Pattern.KnuthMorrisPrattMatcher.prototype.description = "The Knuth–Morris–Pratt algorithm (or KMP algorithm) searches for occurrences of a \"word\" W within a main \"text string\" S by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters."
    Pattern.KnuthMorrisPrattMatcher.prototype._prefix = null;
    Pattern.KnuthMorrisPrattMatcher.prototype.dispose = function( ) {
        this._pattern = null;
        this._prefix = null;
        return this;
    };
    Pattern.KnuthMorrisPrattMatcher.prototype.pattern = function( pattern ) {
        this._pattern = pattern || null;
        if ( this._pattern )
        {
            this._prefix = computePrefix( this._pattern );
        }
        else
        {
            this._prefix = null;
        }
        return this;
    };
    Pattern.KnuthMorrisPrattMatcher.prototype.match = function( s, offset ) {
        var p = this._pattern, prefix = this._prefix,
            n = s.length, m = p.length, i, q
        ;
        
        if ( arguments.length < 2 ) offset = 0;
        if ( offset < 0 ) offset += n;
        if ( n > 0 && m > 0 && n >= offset+m )
        {
            q = 0;  // number of characters matched
            for (i=offset; i<n; i++)
            {
                while ( q > 0 && p.charAt( q ) !== s.charAt( i ) ) 
                {
                    q = prefix[ q ]+1;
                }
                
                if ( p.charAt( q ) === s.charAt( i ) ) q++;  // next character matches
                
                if ( m === q ) return i-m+1;
            }
        }
        return -1;
    };
    
}(Pattern);!function(Pattern, undef){

    "use strict";
    
    //
    //  Boyer-Moore Matcher
    //  http://www.cs.utexas.edu/~moore/publications/fstrpos.pdf
    //  http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm
    //
    
    var max = Math.max, 
        array_fill = Pattern.utils.array_fill, 
        reverse = Pattern.utils.reverse,
        alphabet_index = Pattern.utils.alphabet_index,
        ALPHABET = Pattern.ALPHABET,
        ALPHABET_LEN = ALPHABET.length
    ;
    
    function match_length( s, idx1, idx2 )
    {
        // Returns the length of the match of the substrings of S beginning at idx1 and idx2.
        var sl = s.length, match_count;
        
        if ( idx1 === idx2 )
        {
            return sl - idx1;
        }
        
        match_count = 0;
        while ( idx1 < sl && idx2 < sl && s.charAt( idx1 ) === s.charAt( idx2 ) )
        {
            match_count++;
            idx1++;
            idx2++;
        }
        return match_count;
    }
 
    function fundamental_preprocess( s )
    {
        // Returns Z, the Fundamental Preprocessing of S. Z[i] is the length of the substring 
        // beginning at i which is also a prefix of S. This pre-processing is done in O(n) time,
        // where n is the length of S.
        
        var sl = s.length, i, z, l, r, a, b, k;
        
        if ( 0 === sl ) // Handles case of empty string
        {
            return [ ];
        }
        if ( 1 === sl ) // Handles case of single-character string
        {
            return [ 1 ];
        }
        
        z = array_fill( sl, 0 );
        
        z[ 0 ] = sl;
        z[ 1 ] = match_length(s, 0, 1);
        for (i=2; i<1+z[1]; i++) // Optimization from exercise 1-5
        {
            z[ i ] = z[ 1 ]-i+1;
        }
        // Defines lower and upper limits of z-box
        l = 0;
        r = 0;
        for (i=2+z[1]; i<sl; i++)
        {
            if (i <= r) // i falls within existing z-box
            {
                k = i-l;
                b = z[ k ];
                a = r-i+1;
                if (b < a) // b ends within existing z-box
                {
                    z[ i ] = b;
                }
                else // b ends at or after the end of the z-box, we need to do an explicit match to the right of the z-box
                {
                    z[ i ] = b+match_length(s, a, r+1);
                    l = i;
                    r = i+z[ i ]-1;
                }
            }
            else // i does not reside within existing z-box
            {
                z[ i ] = match_length(s, 0, i);
                if ( z[ i ] > 0 )
                {
                    l = i;
                    r = i+z[ i ]-1;
                }
            }
        }
        return z;
    }
 
    function bad_character_table( s )
    {
        // Generates R for S, which is an array indexed by the position of some character c in the 
        // English alphabet. At that index in R is an array of length |S|+1, specifying for each
        // index i in S (plus the index after S) the next location of character c encountered when
        // traversing S from right to left starting at i. This is used for a constant-time lookup
        // for the bad character rule in the Boyer-Moore string search algorithm, although it has
        // a much larger size than non-constant-time solutions.
        
        var sl = s.length, c, i, j, R, alpha;
        
        if (0 === sl)
        {
            return array_fill(ALPHABET_LEN, function( ){ return [ ]; });
        }
        
        R = array_fill(ALPHABET_LEN, function( ){ return [ -1 ]; });
        alpha = array_fill(ALPHABET_LEN, function( ){ return -1 ; });
        
        for (i=0; i<sl; i++)
        {
            c = s.charAt( i );
            alpha[ alphabet_index( c ) ] = i;
            for (j=0; j<alpha.length; j++)
            {
                R[ j ].push( alpha[ j ] );
            }
        }
        return R;
    }
 
    function good_suffix_table( s )
    {
        // Generates L for S, an array used in the implementation of the strong good suffix rule.
        // L[i] = k, the largest position in S such that S[i:] (the suffix of S starting at i) matches
        // a suffix of S[:k] (a substring in S ending at k). Used in Boyer-Moore, L gives an amount to
        // shift P relative to T such that no instances of P in T are skipped and a suffix of P[:L[i]]
        // matches the substring of T matched by a suffix of P in the previous match attempt.
        // Specifically, if the mismatch took place at position i-1 in P, the shift magnitude is given
        // by the equation len(P) - L[i]. In the case that L[i] = -1, the full shift table is used.
        // Since only proper suffixes matter, L[0] = -1.
        var sl = s.length, i, j, L, N;
        
        L = array_fill( sl, -1 );
        N = fundamental_preprocess( reverse( s ) ).reverse( ); // S[::-1] reverses S
        for (j=0; j<sl/*-1*/; j++)
        {
            i = sl - N[ j ];
            if (i !== sl)
            {
                L[ i ] = j;
            }
        }
        return L;
    }
 
    function full_shift_table( s )
    {
        // Generates F for S, an array used in a special case of the good suffix rule in the Boyer-Moore
        // string search algorithm. F[i] is the length of the longest suffix of S[i:] that is also a
        // prefix of S. In the cases it is used, the shift magnitude of the pattern P relative to the
        // text T is len(P) - F[i] for a mismatch occurring at i-1.
        var sl = s.length, F, Z, longest, i, zv, zl;
        
        F = array_fill( sl, 0 );
        Z = fundamental_preprocess( s );
        zl = Z.length;
        longest = 0
        for (i=0; i<zl; i++) //zv in enumerate(reversed(Z)):
        {
            zv = Z[ zl-1-i ];
            if ( i+1 === zv ) longest = max( zv, longest );
            F[ sl-1-i ] = longest;
        }
        return F;
    }
 
    Pattern.BoyerMooreMatcher = function( pattern ) {
        Pattern.Matcher.call(this, pattern);
    };
    Pattern.BoyerMooreMatcher.prototype = Object.create( Pattern.Matcher.prototype );
    Pattern.BoyerMooreMatcher.prototype._L = null;
    Pattern.BoyerMooreMatcher.prototype._R = null;
    Pattern.BoyerMooreMatcher.prototype._F = null;
    Pattern.BoyerMooreMatcher.prototype.reference = 'http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm';
    Pattern.BoyerMooreMatcher.prototype.description = "The Boyer-Moore algorithm uses information gathered during the preprocess step to skip sections of the text, resulting in a lower constant factor than many other string algorithms. In general, the algorithm runs faster as the pattern length increases. The key feature of the algorithm is to match on the tail of the pattern rather than the head, and to skip along the text in jumps of multiple characters rather than searching every single character in the text."
    Pattern.BoyerMooreMatcher.prototype.dispose = function( ) {
        this._pattern = null;
        this._L = null;
        this._R = null;
        this._F = null;
        return this;
    };
    Pattern.BoyerMooreMatcher.prototype.pattern = function( pattern ) {
        this._pattern = pattern || null;
        if ( this._pattern )
        {
            this._R = bad_character_table( this._pattern );
            this._L = good_suffix_table( this._pattern );
            this._F = full_shift_table( this._pattern );
        }
        else
        {
            this._L = null;
            this._R = null;
            this._F = null;
        }
        return this;
    };
    Pattern.BoyerMooreMatcher.prototype.match = function( s, offset ) {
        // Implementation of the Boyer-Moore string search algorithm. This finds all occurrences of P
        // in T, and incorporates numerous ways of pre-processing the pattern to determine the optimal 
        // amount to shift the string and skip comparisons. In practice it runs in O(m) (and even 
        // sublinear) time, where m is the length of T. This implementation performs a case-insensitive
        // search on ASCII alphabetic characters, spaces not included.
        
        var p = this._pattern, m = p.length, n = s.length,
            R = this._R, L = this._L, F = this._F,
            k, previous_k, i, h, 
            char_shift, suffix_shift, shift
        ;
        
        if ( arguments.length < 2 ) offset = 0;
        if ( offset < 0 ) offset += n;
        if ( n > 0 && m > 0 && n >= offset+m )
        {
            //matches = []
         
            k = offset + m - 1;      // Represents alignment of end of P relative to T
            previous_k = offset -1;     // Represents alignment in previous phase (Galil's rule)
            while ( k < n )
            {
                i = m - 1;  // Character to compare in P
                h = k;           // Character to compare in T
                while (i >= 0 && h > previous_k && p.charAt(i) === s.charAt(h))   // Matches starting from end of P
                {
                    i--;
                    h--;
                }
                if (-1 === i || h === previous_k)  // Match has been found (Galil's rule)
                {
                    return k - m + 1;
                    //matches.append(k - len(P) + 1)
                    //k += len(P)-F[1] if len(P) > 1 else 1
                }
                else   // No match, shift by max of bad character and good suffix rules
                {
                    char_shift = i - R[ alphabet_index( s.charAt( h ) ) ][ i ];
                    if (i+1 === m)   // Mismatch happened on first attempt
                    {
                        suffix_shift = 1;
                    }
                    else if (-1 === L[i+1])   // Matched suffix does not appear anywhere in P
                    {
                        suffix_shift = m - F[i+1];
                    }
                    else               // Matched suffix appears in P
                    {
                        suffix_shift = m - L[i+1];
                    }
                    shift = max( char_shift, suffix_shift );
                    if ( shift >= i+1 ) previous_k = k;  // Galil's rule
                    k += shift;
                }
            }
        }
        return -1;
    };
    
}(Pattern);

    /* main code ends here */
    
    /* export the module "Pattern" */
    return EXPORTS["Pattern"];
});