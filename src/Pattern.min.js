/**
*
*   Pattern.js
*   @version: 1.0.0
*
*   Pattern Matching Algorithms Tests in JavaScript
*   https://github.com/foo123/PatternMatchingAlgorithms
*
**/
!function(e,t,i){"use strict";"object"==typeof module&&module.exports?(module.$deps=module.$deps||{})&&(module.exports=module.$deps[t]=i.call(e)):"function"==typeof define&&define.amd&&"function"==typeof require&&"function"==typeof require.specified&&require.specified(t)?define(t,["module"],function(t){return i.moduleUri=t.uri,i.call(e)}):t in e||(e[t]=i.call(e)||1)&&"function"==typeof define&&define.amd&&define(function(){return e[t]})}("undefined"!=typeof self?self:this,"Pattern",function(t){"use strict";var n,e={VERSION:"1.0.0",Matchy:function(t){n=t},Matcher:function(t,e,i){this.algorithm=t,this.reference=e,this.description=i}};return e.Matcher.prototype={constructor:e.Matcher,algorithm:null,reference:null,description:"",_pattern:null,_matcher:null,_err:0,dispose:function(){return this._pattern=null,this._matcher=null,this},pattern:function(t){return this._pattern=t||null,this._matcher=this._pattern?"function"==typeof this.algorithm?this.algorithm.bind(this):(new n)[this.algorithm](this._pattern):null,this},match:function(t,e){return this._matcher(t,e||0)}},e.NaiveMatcher=new e.Matcher(function(t,e){var i,r=this._pattern,a=t.length,n=r.length;if((e=arguments.length<2?0:e)<0&&(e+=a),0<a&&0<n&&e+n<=a)for(a=a-n+1,i=e;i<a;++i)if(t.slice(i,i+n)===r)return i;return-1},"https://en.wikipedia.org/wiki/String_searching_algorithm","This is a &quot;<i>naive</i>&quot; string search algorithm, in that it tests each succesive position of the input text to see if the pattern matches and does not exploit information about the pattern or the text in order to speed up the search."),e.FuzzyMatcher=new e.Matcher(function(t,e){var i=this._pattern,r=t.length,a=i.length;return(e=arguments.length<2?0:e)<0&&(e+=r),0<r&&0<a&&e+a<=r?new n.NFA(i,{errors:this._err||1}).match(t,e):-1},"https://en.wikipedia.org/wiki/Levenshtein_distance","This is an approximate string search algorithm using Levenshtein distance to find matches that have at most k errors."),e.FSAMatcher=new e.Matcher("fsa","https://en.wikipedia.org/wiki/Finite-state_machine","The Finite State Automaton matcher (or FSA matcher) searches a text for a pattern, by creating a deterministic finite automaton (DFA) which is then used to parse the text. The FSA method is also used for matching a regular expression pattern."),e.RabinKarpMatcher=new e.Matcher("rabinkarp","https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm","The Rabin–Karp algorithm is a string searching algorithm  that uses &quot;<i>hashing</i>&quot; to find any one of a set of pattern strings in a text. For text of length n and p patterns of combined length m, its average and best case running time is O(n+m) in space O(p), but its worst-case time is O(nm)."),e.KnuthMorrisPrattMatcher=new e.Matcher("knuthmorrispratt","https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm","The Knuth–Morris–Pratt algorithm (or KMP algorithm) searches for occurrences of a word W within a main text string S by exploiting the observation that when a mismatch occurs, the word itself contains sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters."),e.BoyerMooreMatcher=new e.Matcher("boyermoore","https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm","The Boyer-Moore algorithm uses information gathered during the preprocess step to skip sections of the text, resulting in a lower constant factor than many other string algorithms. In general, the algorithm runs faster as the pattern length increases. The key feature of the algorithm is to match on the tail of the pattern rather than the head, and to skip along the text in jumps of multiple characters rather than searching every single character in the text."),e.TwoWayMatcher=new e.Matcher("twoway","https://en.wikipedia.org/wiki/Two-way_string-matching_algorithm","The two-way algorithm can be viewed as a combination of the forward-going Knuth–Morris–Pratt algorithm (KMP) and the backward-running Boyer–Moore string-search algorithm (BM). Like those two, the 2-way algorithm preprocesses the pattern to find partially repeating periods and computes <i>shifts</i> based on them, indicating what offset to <i>jump</i> to in the searched text when a given character is encountered."),e.CommentzWalterMatcher=new e.Matcher("commentzwalter","https://en.wikipedia.org/wiki/Commentz-Walter_algorithm","TODO"),e.BaezaYatesGonnetMatcher=new e.Matcher("baezayatesgonnet","https://en.wikipedia.org/wiki/Bitap_algorithm","TODO"),e.AhoCorasickMatcher=new e.Matcher("ahocorasick","https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm","TODO"),e});